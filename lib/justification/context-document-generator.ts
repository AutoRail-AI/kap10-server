/**
 * Context document generator — compiles features, health report, ADRs, and
 * ontology into a downloadable UNERR_CONTEXT.md markdown artifact.
 */

import type { IGraphStore } from "@/lib/ports/graph-store"

export async function generateContextDocument(
  orgId: string,
  repoId: string,
  graphStore: IGraphStore
): Promise<string> {
  const [projectStats, healthReport, features, ontology, adrs] =
    await Promise.all([
      graphStore.getProjectStats(orgId, repoId).catch(() => null),
      graphStore.getHealthReport(orgId, repoId).catch(() => null),
      graphStore.getFeatureAggregations(orgId, repoId).catch(() => []),
      graphStore.getDomainOntology(orgId, repoId).catch(() => null),
      graphStore.getADRs(orgId, repoId).catch(() => []),
    ])

  const lines: string[] = []
  const projectName = ontology?.project_name ?? "Project"
  const date = new Date().toISOString().split("T")[0]

  // Header
  lines.push(`# ${projectName} — Code Intelligence Report`)
  lines.push(`> Auto-generated by unerr on ${date}`)
  lines.push("")

  // Project Overview
  lines.push("## Project Overview")
  lines.push("")
  if (ontology?.project_description) {
    lines.push(ontology.project_description)
    lines.push("")
  }
  if (ontology?.tech_stack && ontology.tech_stack.length > 0) {
    lines.push(`**Tech Stack:** ${ontology.tech_stack.join(", ")}`)
    lines.push("")
  }
  if (ontology?.project_domain) {
    lines.push(`**Domain:** ${ontology.project_domain}`)
    lines.push("")
  }

  // Architecture Health
  if (healthReport) {
    const totalEntities = healthReport.total_entities
    const justified = healthReport.justified_entities
    const avgPct = Math.round(healthReport.average_confidence * 100)
    const highRisks = healthReport.risks.filter((r) => r.severity === "high").length
    const medRisks = healthReport.risks.filter((r) => r.severity === "medium").length
    const grade =
      highRisks >= 3 ? "F" : highRisks >= 1 ? "D" : medRisks > 3 ? "C" : medRisks > 0 ? "B" : "A"

    lines.push(`## Architecture Health: Grade ${grade}`)
    lines.push("")
    lines.push(
      `${totalEntities} entities analyzed, ${justified} justified, ${avgPct}% avg confidence`
    )
    lines.push("")

    if (healthReport.risks.length > 0) {
      lines.push("### Key Risks")
      lines.push("")
      for (const risk of healthReport.risks) {
        const severity = risk.severity.toUpperCase()
        lines.push(`- **[${severity}]** ${risk.description}`)
      }
      lines.push("")
    }
  }

  // Entity Stats
  if (projectStats) {
    lines.push("## Entity Statistics")
    lines.push("")
    lines.push(`| Metric | Count |`)
    lines.push(`| ------ | ----- |`)
    lines.push(`| Files | ${projectStats.files} |`)
    lines.push(`| Functions | ${projectStats.functions} |`)
    lines.push(`| Classes | ${projectStats.classes} |`)
    lines.push(`| Interfaces | ${projectStats.interfaces} |`)
    lines.push(`| Variables | ${projectStats.variables} |`)
    lines.push("")

    if (projectStats.languages && Object.keys(projectStats.languages).length > 0) {
      lines.push("### Languages")
      lines.push("")
      const sorted = Object.entries(projectStats.languages).sort((a, b) => b[1] - a[1])
      for (const [lang, count] of sorted) {
        lines.push(`- ${lang}: ${count} files`)
      }
      lines.push("")
    }
  }

  // Feature Map
  if (features.length > 0) {
    lines.push("## Feature Map")
    lines.push("")
    for (const feature of features) {
      const taxonomyParts = Object.entries(feature.taxonomy_breakdown)
        .map(([t, c]) => `${c} ${t}`)
        .join(", ")
      const avgPct = Math.round(feature.average_confidence * 100)

      lines.push(`### ${feature.feature_tag}`)
      lines.push("")
      lines.push(
        `${feature.entity_count} entities | ${taxonomyParts} | ${avgPct}% avg confidence`
      )

      if (feature.entry_points.length > 0) {
        lines.push("")
        lines.push(`**Entry points:** ${feature.entry_points.slice(0, 5).join(", ")}`)
      }
      lines.push("")
    }
  }

  // ADRs
  if (adrs.length > 0) {
    lines.push("## Architecture Decision Records")
    lines.push("")
    for (const adr of adrs) {
      lines.push(`### ${adr.title}`)
      lines.push("")
      lines.push(`**Context:** ${adr.context}`)
      lines.push("")
      lines.push(`**Decision:** ${adr.decision}`)
      lines.push("")
      if (adr.consequences) {
        lines.push(`**Consequences:** ${adr.consequences}`)
        lines.push("")
      }
    }
  }

  // Domain Glossary
  if (ontology && ontology.terms.length > 0) {
    lines.push("## Domain Glossary")
    lines.push("")
    lines.push("| Term | Frequency | Related Terms |")
    lines.push("| ---- | --------- | ------------- |")
    const sortedTerms = [...ontology.terms].sort((a, b) => b.frequency - a.frequency)
    for (const term of sortedTerms.slice(0, 50)) {
      const related = term.relatedTerms.length > 0 ? term.relatedTerms.join(", ") : "—"
      lines.push(`| ${term.term} | ${term.frequency} | ${related} |`)
    }
    lines.push("")
  }

  // Ubiquitous Language
  if (ontology?.ubiquitous_language && Object.keys(ontology.ubiquitous_language).length > 0) {
    lines.push("## Ubiquitous Language")
    lines.push("")
    lines.push("| Term | Definition |")
    lines.push("| ---- | ---------- |")
    for (const [term, definition] of Object.entries(ontology.ubiquitous_language)) {
      lines.push(`| ${term} | ${definition} |`)
    }
    lines.push("")
  }

  // Footer
  lines.push("---")
  lines.push("")
  lines.push("*Generated by [unerr](https://unerr.io) — Code Intelligence Platform*")

  return lines.join("\n")
}
