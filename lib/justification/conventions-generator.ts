/**
 * TBI-I-05: Team conventions export generator.
 *
 * Generates a TEAM_CONVENTIONS.md document from detected patterns, rules,
 * and architecture decisions. Also supports .cursorrules format for IDE integration.
 */

import type { IGraphStore } from "@/lib/ports/graph-store"
import type { PatternDoc, RuleDoc, DomainOntologyDoc } from "@/lib/ports/types"

/**
 * Generate a TEAM_CONVENTIONS.md document summarizing all detected patterns,
 * architecture rules, and naming conventions for a repository.
 */
export async function generateConventionsDocument(
  orgId: string,
  repoId: string,
  graphStore: IGraphStore,
  options?: { format?: "markdown" | "cursorrules" }
): Promise<string> {
  const format = options?.format ?? "markdown"

  const [patterns, rules, ontology] = await Promise.all([
    graphStore.queryPatterns(orgId, {
      orgId,
      repoId,
      status: "confirmed",
      limit: 100,
    }).catch((): PatternDoc[] => []),
    graphStore.queryRules(orgId, {
      orgId,
      repoId,
      status: "active",
      limit: 100,
    }).catch((): RuleDoc[] => []),
    graphStore.getDomainOntology(orgId, repoId).catch((): null => null),
  ])

  if (format === "cursorrules") {
    return generateCursorRules(patterns, rules, ontology)
  }

  return generateMarkdown(patterns, rules, ontology)
}

function generateMarkdown(
  patterns: PatternDoc[],
  rules: RuleDoc[],
  ontology: DomainOntologyDoc | null
): string {
  const lines: string[] = []
  const projectName = ontology?.project_name ?? "Project"
  const date = new Date().toISOString().split("T")[0]

  lines.push(`# ${projectName} — Team Conventions`)
  lines.push(`> Auto-generated by unerr on ${date}`)
  lines.push("")

  if (ontology?.tech_stack && ontology.tech_stack.length > 0) {
    lines.push(`**Tech Stack:** ${ontology.tech_stack.join(", ")}`)
    lines.push("")
  }

  // Architecture Rules
  const blockingRules = rules.filter((r) => r.enforcement === "block")
  const warningRules = rules.filter((r) => r.enforcement === "warn")
  const suggestRules = rules.filter((r) => r.enforcement !== "block" && r.enforcement !== "warn")

  if (rules.length > 0) {
    lines.push("## Architecture Rules")
    lines.push("")

    if (blockingRules.length > 0) {
      lines.push("### Mandatory (MUST)")
      lines.push("")
      for (const rule of blockingRules) {
        lines.push(`- **${rule.title}**: ${rule.description}`)
      }
      lines.push("")
    }

    if (warningRules.length > 0) {
      lines.push("### Recommended (SHOULD)")
      lines.push("")
      for (const rule of warningRules) {
        lines.push(`- **${rule.title}**: ${rule.description}`)
      }
      lines.push("")
    }

    if (suggestRules.length > 0) {
      lines.push("### Optional (MAY)")
      lines.push("")
      for (const rule of suggestRules) {
        lines.push(`- **${rule.title}**: ${rule.description}`)
      }
      lines.push("")
    }
  }

  // Detected Patterns by Type
  if (patterns.length > 0) {
    lines.push("## Detected Conventions")
    lines.push("")

    const byType = new Map<string, PatternDoc[]>()
    for (const p of patterns) {
      const group = byType.get(p.type) ?? []
      group.push(p)
      byType.set(p.type, group)
    }

    const typeEntries = Array.from(byType.entries())
    for (const [type, typePatterns] of typeEntries) {
      const label = type.charAt(0).toUpperCase() + type.slice(1).replace(/-/g, " ")
      lines.push(`### ${label} Patterns`)
      lines.push("")

      for (const p of typePatterns.sort((a: PatternDoc, b: PatternDoc) => b.adherenceRate - a.adherenceRate)) {
        const rate = Math.round(p.adherenceRate * 100)
        const conf = Math.round(p.confidence * 100)
        lines.push(`- **${p.title}** (${rate}% adherence, ${conf}% confidence)`)
        if (p.evidence && p.evidence.length > 0) {
          lines.push(`  Examples: ${p.evidence.slice(0, 3).map((e) => `\`${e.file}\``).join(", ")}`)
        }
      }
      lines.push("")
    }
  }

  if (rules.length === 0 && patterns.length === 0) {
    lines.push("No conventions detected yet. Run pattern detection to discover project conventions.")
    lines.push("")
  }

  lines.push("---")
  lines.push("")
  lines.push("*Generated by [unerr](https://unerr.io) — Code Intelligence Platform*")

  return lines.join("\n")
}

function generateCursorRules(
  patterns: PatternDoc[],
  rules: RuleDoc[],
  ontology: DomainOntologyDoc | null
): string {
  const lines: string[] = []

  if (ontology?.tech_stack && ontology.tech_stack.length > 0) {
    lines.push(`# Tech Stack: ${ontology.tech_stack.join(", ")}`)
    lines.push("")
  }

  // Mandatory rules first
  const blockingRules = rules.filter((r) => r.enforcement === "block")
  if (blockingRules.length > 0) {
    lines.push("# MANDATORY RULES")
    lines.push("")
    for (const rule of blockingRules) {
      lines.push(`- ${rule.title}: ${rule.description}`)
    }
    lines.push("")
  }

  // Warning rules
  const warningRules = rules.filter((r) => r.enforcement === "warn")
  if (warningRules.length > 0) {
    lines.push("# RECOMMENDED PATTERNS")
    lines.push("")
    for (const rule of warningRules) {
      lines.push(`- ${rule.title}: ${rule.description}`)
    }
    lines.push("")
  }

  // High-confidence patterns
  const highConfidence = patterns.filter((p) => p.confidence > 0.7 && p.adherenceRate > 0.6)
  if (highConfidence.length > 0) {
    lines.push("# CODE CONVENTIONS")
    lines.push("")
    for (const p of highConfidence) {
      lines.push(`- ${p.title} (${Math.round(p.adherenceRate * 100)}% of codebase follows this)`)
    }
    lines.push("")
  }

  return lines.join("\n")
}
