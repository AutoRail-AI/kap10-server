/**
 * ADR generation activities — assess significance, generate ADR, commit as PR.
 */

import { getContainer } from "@/lib/di/container"
import { AdrSchema, renderAdrMarkdown, formatAdrFilename } from "@/lib/review/adr-schema"
import type { AdrContent } from "@/lib/ports/types"

export interface SignificanceAssessment {
  significant: boolean
  reason: string
  newEntityCount: number
  newFeatureAreas: string[]
  boundaryChanges: string[]
}

export async function assessMergeSignificance(input: {
  orgId: string
  repoId: string
  prNumber: number
}): Promise<SignificanceAssessment> {
  const container = getContainer()

  // Get latest index events to see new entity counts
  const events = await container.graphStore.getIndexEvents(input.orgId, input.repoId, 5)
  const recentEvent = events[0]

  const newEntityCount = recentEvent
    ? recentEvent.entities_added
    : 0

  // Check for new feature areas
  const aggregations = await container.graphStore.getFeatureAggregations(input.orgId, input.repoId)
  const newFeatureAreas = aggregations
    .filter((a) => {
      const created = new Date(a.created_at)
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000)
      return created > oneDayAgo
    })
    .map((a) => a.feature_tag)

  // Check for new boundary files
  const allEntities = await container.graphStore.getAllEntities(input.orgId, input.repoId)
  const boundaryChanges = allEntities
    .filter((e) => {
      const path = e.file_path
      return (
        path.startsWith("lib/adapters/") ||
        path.startsWith("lib/ports/") ||
        path.startsWith("lib/use-cases/")
      )
    })
    .slice(0, 5)
    .map((e) => e.file_path)

  const threshold = parseInt(process.env.ADR_SIGNIFICANCE_THRESHOLD ?? "10", 10)
  const significant = newEntityCount >= threshold || newFeatureAreas.length > 0 || boundaryChanges.length > 0

  return {
    significant,
    reason: significant
      ? `${newEntityCount} new entities, ${newFeatureAreas.length} new feature areas, ${boundaryChanges.length} boundary changes`
      : "Low significance merge",
    newEntityCount,
    newFeatureAreas,
    boundaryChanges,
  }
}

export async function generateAdr(input: {
  orgId: string
  repoId: string
  prNumber: number
  prTitle: string
  assessment: SignificanceAssessment
}): Promise<AdrContent> {
  const container = getContainer()

  const result = await container.llmProvider.generateObject({
    model: "claude-sonnet-4-20250514",
    schema: AdrSchema,
    prompt: `Generate an Architecture Decision Record for this merged PR:

PR #${input.prNumber}: ${input.prTitle}
New entities: ${input.assessment.newEntityCount}
New feature areas: ${input.assessment.newFeatureAreas.join(", ") || "none"}
Boundary changes: ${input.assessment.boundaryChanges.join(", ") || "none"}

Follow the ADR format:
- Title (short, descriptive)
- Context (what problem was being solved)
- Decision (what was built)
- Consequences (what this means for the codebase going forward)
- Related entities and feature areas`,
  })

  // Log token usage
  await container.graphStore.logTokenUsage(input.orgId, {
    id: `adr-${Date.now()}`,
    org_id: input.orgId,
    repo_id: input.repoId,
    model: "claude-sonnet-4-20250514",
    input_tokens: result.usage.inputTokens,
    output_tokens: result.usage.outputTokens,
    activity: "adr-generation",
    created_at: new Date().toISOString(),
  })

  return result.object
}

export async function commitAdrPr(input: {
  orgId: string
  repoId: string
  owner: string
  repo: string
  prNumber: number
  installationId: number
  headSha: string
  adrContent: AdrContent
}): Promise<{ prNumber: number; prUrl: string }> {
  const container = getContainer()

  const adrFilename = formatAdrFilename(input.adrContent.title)
  const adrMarkdown = renderAdrMarkdown(input.adrContent, input.prNumber)
  const branchName = `kap10/adr-pr-${input.prNumber}`

  // Create branch
  await container.gitHost.createBranch(input.owner, input.repo, branchName, input.headSha)

  // Create file
  await container.gitHost.createOrUpdateFile(
    input.owner,
    input.repo,
    branchName,
    adrFilename,
    adrMarkdown,
    { message: `docs: add ADR for PR #${input.prNumber} — ${input.adrContent.title}` }
  )

  // Create PR
  const pr = await container.gitHost.createPullRequest(input.owner, input.repo, {
    title: `docs: ADR — ${input.adrContent.title}`,
    body: `## Auto-generated Architecture Decision Record\n\nThis ADR was automatically generated by kap10 based on the changes in PR #${input.prNumber}.\n\n**Review and merge to keep architectural documentation up-to-date.**`,
    head: branchName,
    base: "main",
  })

  return { prNumber: pr.number, prUrl: pr.htmlUrl ?? "" }
}
